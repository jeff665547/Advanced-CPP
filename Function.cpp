// 1. 在C++中，函式也是一個物件，在函式名稱後方加上"()"(i.e. 函式呼叫)則會去執行函式內部包起來的程式碼。
// 2. 在使用函式之前要先有其實作定義或是宣告，使用函式名稱時的邏輯順序與變數名稱可視範圍相同。
// 3. 函式宣告(宣告某個名稱是個函式)以及函式定義(定義某個名稱的函式被呼叫時要做甚麼事情)彼此之間是可以
//    分開的(也可以分開放到不同的檔案)，函式宣告和定義彼此之間是靠著名稱以及簽章(signature, 參數個數及型態)
//    去串聯的。
// 4. 在函式宣告的時候，如 void f(); (先看名字右邊)在名字f右邊是小括弧，代表它是個函式，
//    (再看名字左邊)左邊代表此函式的回傳值型態。
// 5. 函式(包含main函式)定義內部不能"定義"其他一般函式，因為函式名稱在C中規定要是命名空間中全域的名字。
// 6. 參數與引數，函式呼叫時，函式參數(parameter)以引數(argument)進行初始化(initialization)，預設是使用
//    複製的方式。
// 7. 函式的回傳值(xxx in return xxx;)預設會被"複製"到它被呼叫的地方。
// 8. 函式的回傳值如果是用複製的(預設)，它是沒有名稱的一個暫時物件，此時函式的回傳值為一種右值表示式。
//    函式的回傳值如果是用參考的，代表它和函式內部的物件是同一份，此時函式的回傳值為一種左值表示式，
//    也就是說可以寫成(f() = 3;)，若函式的回傳值是用參考的，則不能去參考函式內部產生的物件
//    (即區域變數(包含非參考類型的參數))，該物件(區域變數)會因為函式結束而隨之解構，
//    因此函式的回傳值會參考到不存在的物件，進而發生未定義行為。
// 9. 生命週期是指執行到可視範圍中某行程式碼的時候產生，執行到離開可視範圍時會死亡

#include <iostream>

void f(const char*, const char);  // 宣告時，參數名稱可以省略(但建議不要)。

void f(int fa) {}

void g(int ga) {}

void g(float ga) {}

int& j(int aa) {  // 因為函式的參數(aa)屬於區域變數，因此在這邊回傳區域變數的參考是會有問題的
                  // (離開可視範圍後區域變數生命週期結束、未定義行為)。
    return aa;    
}

int main(){

    f(1); // -> 1 為引數，f中的fa叫做參數，函式呼叫時int fa = 1，函式參數(parameter)以引數(argument)進行初始化
    f("abc", 'n');  // 編譯器會依照引數和參數的型態相似性(除了參數的型態是參考之外，其餘的參數可透過將引數隱性轉
                    // 型)以及參數個數去匹配函數。

    // g(3.2)  // -> 編譯錯誤，因為g(3.2)有兩種可能(3.2為double型態，g函式的兩種可能皆需要轉型，且可能發生溢位)，
               //    沒有較為適合的候選函式，因此編譯結果是ambiguous。

    return 0;
}

void f(const char* ss, const char s) {
    std::cout << ss << s << std::endl;
}