// 0. "編譯"的過程:高階語言(如:int main() {}) -> 組合語言(如:movq %rsp, %rbp) -> 機器語言(如:cffa edfe 0700 0001)
// 1. 程式碼(*.cpp)會先經過前置處理(preprocess: 指#開頭的指令, 類似文書處理器的動作, 如:#include就是複製貼上), 
//    再經過編譯(compile: 編譯時以函式為單位，進行語法檢查(檢查函式宣告)以及語意分析，告訴連結器要怎麼連結)形成目的檔(*.o), 
//    最後在將多個目的檔(*.o)連結(link: 實際連結不同函式彼此之間的實作定義(檢查函式實作定義)，處理跨函式的關係, 
//    如讓不同函式可以彼此呼叫, 也會檢查有無main()函式)成執行檔(*.exe)
// 2. 常見的編譯(compile)錯誤: 函式呼叫前沒有宣告也沒有定義函式。
//    常見的連結(link)錯誤: undefined reference to ...   ld returned 1 exit status. 
//    => 代表根據compile時的連結方式找不到函式定義，ld代表連結器的意思。
//    Compile 成功代表每一個名字都有剛好對應到一個宣告的用法 (如: void AA(int input)) 以及有相對應的定義，
//    Link 成功則代表每一個"用到"的函式都有定義 (如: void AA(int input) {})。
//    Run 成功代表著程式行為符合預期。
// 3. 在執行期才知道某些值是多少(e.g. 使用者輸入、複雜計算結果)，被稱為動態。
//    若是在編譯時就知道某些值要被設成多少，也就是寫程式時當下就要知道值是多少，則被稱為靜態。
//    靜態寫法有時候會有機會得到效率的提升。
// 4. C語言範疇(陣列(T[]) 字串(char[]) 指標(*) 流程控制(if, for) 函式(F()) 函式庫), 
//    C++語言範疇(陣列(array) 字串(string) 指標(智慧指標, 參考T&, 動態陣列vector, 函式物件, 迭代器) 
//               流程控制(if, for) 函式(F()) 模板庫), 
//    再大多數時候建議直接使用C++範疇的東西, 然而C語言範疇的東西也能用, 但較不推薦。
// 5. 在C++中, 若main函式沒有在最結尾的地方加上return 0;的話(意即沒有指定回傳值), 則main()會自動return 0;。
// 6. 輸出 std::endl 會印換行字元並且自動清出緩衝區(buffer)裡面的內容到輸出裝置, buffer其實就是指一塊記憶體, 
//    每次執行輸出時會先輸出到緩衝區, 等到緩衝區寫到一個段落差不多的時後, 需要的時候, 就可以一次輸出到輸出裝置。
//    在現在一般的實作上，輸出換行字元"\n"也會同時會清理緩衝區。
// 7. C++能支援各種程式設計範式(Programming Paradigm):
//    1. 程序式程式設計 (Procedural Programming) -> 仰賴函式
//    2. 基於物件的程式設計 (Object-Based Programming) -> 仰賴類別
//    3. 泛型程式設計 (Generic Programming) -> 仰賴模板(類別產生器、函式產生器)
//    4. 物件導向程式設計 (Object-Oriented Programming) -> 仰賴繼承(在執行時，讓不同的類別當作同樣的類別使用，動態多型)
//    5. 函數式程式設計 (Functional Programming) -> 仰賴匿名函式(在函式中傳遞函式 -> 用函式去改變函式行為的工作)
// 8. C++的賦值運算(assign operator)是去將記憶體上的物件值做改變, 變數是有名字的物件, 暫時物件是沒有名字的物件。
// 9. 未定義行為: 編譯器不一定會指明錯誤, 編譯完成後可以執行, 但其結果行為無法被確定，行為結果會時常變化。
// 10. 實作定義：編譯器有定義，但是結果會依據不同的編譯器而給出不同的定義，進而有不同的結果。
// 11. 編譯錯誤：語法有問題。
// 12. 隱性轉型的實作方式：1. 單一參數的建構子(產生新物件)  2. 多載轉型運算子(產生新物件)  3. 衍生類別物件可以利用繼承關係，
//                                                                                     隱性轉型基底類別物件(不會產生新物件)。
// 13. 物件所佔據在記憶體中的大小是可以經由型別的確定而被知道的。
int main() {}