/* 名稱可視範圍(scope)與命名空間(namespace) */
// * 可視範圍是編譯期就決定的，其和執行的順序無關，也就是說變數名稱能否被使用和
//   程式運(執)行的順序無關(和執行順序有關的叫做生命週期)，只和程式碼編寫的順序有關。
// * 名稱的可視範圍分為三種
//   1. 區域範圍 (Local scope) 宣告定義在{}內的(包含函式參數名稱)。
//      名稱(字)取在區域範圍內的變數以及函式參數都是區域變數。
//   2. 命名空間可視範圍 (Namespace scope) 宣告定義在namespace{}內的(包含全域變數名稱)。
//   3. 類別可視範圍 (Class scope) 宣告定義在class{}內的。
// * 在同樣一組可視範圍的區塊({})裡同樣名稱只能宣告定義一個。
// * 同樣的名稱在全域也只能宣告定義一個。
// * 函式的名字也是一種全域的名稱。
// * 命名空間 Namespace
//   * 讓全域名稱(字)有獨一無二的路徑(名稱)以方便管理以及存取。
//   * 命名空間的語法(namespace 命名空間名稱(字) {...})。
//   * 在命名空間裡所產生的名稱(字)，他的全名就會變長(命名空間名稱(字)::(變數、函式)名稱(字))。
//   * 使用命名空間內名稱(字)的方法：
//     1. 直接存取：絕對名稱 -- 命名空間名稱(字)::名稱(字) e.g. std::cout;
//     2. 間接存取：使用 using namespace 命名空間名稱(字); e.g. using namespace std; cout;
// * 以函式定義為單位，函式內部區域(包含參數)叫做區域可視範圍，函式外部叫做全域(沒有名字的命名空
//   間可視範圍)，函式名稱屬於全域(沒有名字的命名空間可視範圍)。 
// * 區域可視範圍和命名空間無關，在區域範圍內使用的名稱會依照距離較近的名稱去尋找及存取(名稱遮蔽)，
//   只有全域的名稱才會有獨一無二的絕對名稱(命名空間名稱(字)::名稱(字))可以被直接指定使用。

#include <iostream>

// * 全域範圍，在C++中又被叫做沒有名字的命名空間可視範圍(namespace)。
int i = 1;  // i的全名叫做::i。

namespace a { // 有名字(a, ::a)的命名空間可視範圍。
    int b = 3;  // b的全名叫做::a::b
}

namespace d { // 有名字(a, ::a)的命名空間可視範圍。
    int b = 99;  // b的全名叫做::a::b
}

int b = 5;  // 沒有名字的命名空間可視範圍，b的全名叫做::b。

void f(int x) {  // * f 在沒有名字的命名空間可視範圍(全名叫做::f)， x 屬於區域可視範圍
    // * 區域可視範圍
}

// * 函式名稱本身屬於全域範圍(沒有名字的命名空間可視範圍)，如此處的main函式名稱。
int main(){  // * 區域可視範圍
    std::cout << ::b << std::endl;      // * 5
    std::cout << ::a::b << std::endl;   // * 3
    std::cout << b << std::endl;        // -> 先在區域可視範圍中尋找b，如果有的話，找區域中最近的b。
                                        //    如果沒有的話會自動到全域範圍找。內建會自動冠上前綴::，
                                        //    也就是::b => 5。
    std::cout << a::b << std::endl;     // -> 先在區域可視範圍中尋找a::b，但因區域變數的名稱(字)不
                                        //    會出現::，所以會自動到全域範圍找，並自動冠上前綴::，
                                        //    也就是::a::b => 3。
    int b = 7;
    std::cout << b << std::endl;        // -> 先在區域可視範圍中尋找b，如果有的話，找區域中最近的b。
                                        //     => 7。
    std::cout << ::b << std::endl;      // -> 先在區域可視範圍中尋找::b，如果有的話，找區域中最近的
                                        //    b。但因區域變數的名稱(字)不會出現::，所以會自動到全域
                                        //    範圍找，此處因為已經有前綴::了，因此不會再自動冠上前
                                        //    綴::，因此最後的結果就會是::b。 => 5 (此例中的::為強調
                                        //    用法，用來指名要全域的b)。
    using namespace d;                  // * 此語法會替接下來名稱的尋找範圍省略前綴，此語法在使用上通
                                        //   常不會放在全域的範圍內。
    std::cout << b << std::endl;        // -> 先在區域可視範圍中尋找b，如果有的話，找區域中最近的b。
                                        //    如果沒有的話會自動到全域範圍以及::d::中找。內建會自動冠
                                        //    上相對應的前綴(::b, ::d::b)，如果全域範圍以及::d::中都
                                        //    有b的話，則編譯器會報ambiguous，而此處結果為區域變數 b 
                                        //    => 7。
    {
        int b = 9;
    }
    std::cout << i;       // i = 1;  這邊所使用的i就是main外面的i，這個是由寫程式時的可視範圍所決定的。
    int i = 2;            // (*)
    std::cout << i;       // i = 2;  這邊所使用的i就是上面一行的i，這個是由寫程式時的可視範圍所決定的。
    {
        std::cout << i;   // i = 2;  這邊所使用的i是{}外面的i，這個是由寫程式時的可視範圍所決定的。
        int i = 3;
        std::cout << i;   // i = 3;  這邊所使用的i就是上面一行的i，這個是由寫程式時的可視範圍所決定的。
                          //         在此處無法拿到(*)的i來使用(除非使用不同的名稱)，因為i是在區域的範
                          //         圍內。
    }
    std::cout << i;       // i = 2;  這邊所使用的i就是(*)的i，這個是由寫程式時的可視範圍所決定的。
    
    return 0;
}